syntax = "proto3";
package spire.api.entry.v1;
option go_package = "github.com/spiffe/spire/proto/spire/next/api/entry/v1;entry";

import "google/protobuf/empty.proto";
import "spire/next/types/entry.proto";
import "spire/next/types/selector.proto";

// Manages registration entries stored by the SPIRE Server.
service Entry {
    // Lists entries.
    rpc ListEntries(ListEntriesRequest) returns (ListEntriesResponse);

    // Gets an entry by ID. If the entry does not exist, NOT_FOUND is returned.
    rpc GetEntry(GetEntryRequest) returns (spire.types.Entry);

    // Creates an entry. If an entry like it already exists, ALREADY_EXISTS is returned.
    rpc CreateEntry(CreateEntryRequest) returns (spire.types.Entry);

    // Creates one or more entries in a batch.
    rpc BatchCreateEntry(BatchCreateEntryRequest) returns (BatchCreateEntryResponse);

    // Updates an entry. If the entry ID does not exist, NOT_FOUND is returned.
    rpc UpdateEntry(UpdateEntryRequest) returns (spire.types.Entry);

    // Deletes the entry identified by the request. If the entry does not exist,
    // NOT_FOUND is returned.
    rpc DeleteEntry(DeleteEntryRequest) returns (google.protobuf.Empty);

    // Deletes one or more entries identified by the request.
    rpc BatchDeleteEntry(BatchDeleteEntryRequest) returns (BatchDeleteEntryResponse);
}

message ListEntriesRequest {
    message Filter {
        string by_parent_id = 1;
        spire.types.SelectorMatch by_selectors = 2;
        string by_spiffe_id = 3;
    }

    // Filters the entries returned in the response.
    //
    // TODO: How to document optional fields?
    Filter filter = 1;

    // Masks the entry fields returned in the response.
    spire.types.EntryMask mask = 2;

    // The maximum number of entries to return.
    int32 page_size = 3;

    // The `next_page_token` value obtained from the previous `ListEntriesResponse` message, if any.
    string page_token = 4;
}

message ListEntriesResponse {
    // The list of entries.
    repeated spire.types.Entry entries = 1;

    // The token to use as the value for `page_token` in the next `ListEntriesRequest`.
    string next_page_token = 2;
}

message GetEntryRequest {
    // ID of the entry to get.
    string id = 1;

    // Masks the entry fields returned in the response.
    spire.types.EntryMask mask = 2;
}

// TODO: Do we never need a response message? CreateEntryIfNotExists needed
// one to tell the caller whether the record was preexisting or not.
//
message CreateEntryRequest {
    // The entry to be created. The entry ID field is output only, and will be ignored here.
    spire.types.Entry entry = 1;

    // Masks the entry fields returned in the response.
    spire.types.EntryMask mask = 2;
}

message BatchCreateEntryRequest {
    // The entries to be created. The entry ID field is output only, and will be ignored here.
    repeated spire.types.Entry entries = 1;

    // Masks the entry fields returned in the response.
    spire.types.EntryMask mask = 2;
}

message BatchCreateEntryResponse {
    // The entries that were created.
    repeated spire.types.Entry entries = 1;

    // TODO: error map!
}

message UpdateEntryRequest {
    // The updated entry.
    spire.types.Entry entry = 1;

    // Masks the entry fields returned in the response
    spire.types.EntryMask mask = 3;
}

message DeleteEntryRequest {
    // ID of the entry to delete.
    string id = 1;
}

message BatchDeleteEntryRequest {
    // IDs of the entries to delete.
    repeated string id = 1;
}

message BatchDeleteEntryResponse {
    // Errors that occured while deleting the requested entries, if any, keyed
    // by entry ID.
    //
    // TODO: will this broadly work?
    map<string, google.rpc.Status> errors = 1;
}
