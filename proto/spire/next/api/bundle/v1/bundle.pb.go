// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bundle.proto

package bundle

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	types "github.com/spiffe/spire/proto/spire/next/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ListBundlesRequest struct {
	// The maximum number of items to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The next_page_token value returned from a previous List request, if any.
	PageToken            string   `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBundlesRequest) Reset()         { *m = ListBundlesRequest{} }
func (m *ListBundlesRequest) String() string { return proto.CompactTextString(m) }
func (*ListBundlesRequest) ProtoMessage()    {}
func (*ListBundlesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{0}
}

func (m *ListBundlesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListBundlesRequest.Unmarshal(m, b)
}
func (m *ListBundlesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListBundlesRequest.Marshal(b, m, deterministic)
}
func (m *ListBundlesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBundlesRequest.Merge(m, src)
}
func (m *ListBundlesRequest) XXX_Size() int {
	return xxx_messageInfo_ListBundlesRequest.Size(m)
}
func (m *ListBundlesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBundlesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBundlesRequest proto.InternalMessageInfo

func (m *ListBundlesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListBundlesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type ListBundlesResponse struct {
	// The bundles.
	Bundles []*types.Bundle `protobuf:"bytes,1,rep,name=bundles,proto3" json:"bundles,omitempty"`
	// The page token for the next request. Empty if there are no more results.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBundlesResponse) Reset()         { *m = ListBundlesResponse{} }
func (m *ListBundlesResponse) String() string { return proto.CompactTextString(m) }
func (*ListBundlesResponse) ProtoMessage()    {}
func (*ListBundlesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{1}
}

func (m *ListBundlesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListBundlesResponse.Unmarshal(m, b)
}
func (m *ListBundlesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListBundlesResponse.Marshal(b, m, deterministic)
}
func (m *ListBundlesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBundlesResponse.Merge(m, src)
}
func (m *ListBundlesResponse) XXX_Size() int {
	return xxx_messageInfo_ListBundlesResponse.Size(m)
}
func (m *ListBundlesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBundlesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListBundlesResponse proto.InternalMessageInfo

func (m *ListBundlesResponse) GetBundles() []*types.Bundle {
	if m != nil {
		return m.Bundles
	}
	return nil
}

func (m *ListBundlesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type GetBundleRequest struct {
	// The trust domain of the bundle, e.g. example.org. If unset, the bundle
	// for the trust domain that the server belongs to is returned.
	TrustDomain          string   `protobuf:"bytes,1,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBundleRequest) Reset()         { *m = GetBundleRequest{} }
func (m *GetBundleRequest) String() string { return proto.CompactTextString(m) }
func (*GetBundleRequest) ProtoMessage()    {}
func (*GetBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{2}
}

func (m *GetBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetBundleRequest.Unmarshal(m, b)
}
func (m *GetBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetBundleRequest.Marshal(b, m, deterministic)
}
func (m *GetBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBundleRequest.Merge(m, src)
}
func (m *GetBundleRequest) XXX_Size() int {
	return xxx_messageInfo_GetBundleRequest.Size(m)
}
func (m *GetBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBundleRequest proto.InternalMessageInfo

func (m *GetBundleRequest) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

type CreateBundleRequest struct {
	// Required. The bundle to create.
	Bundle               *types.Bundle `protobuf:"bytes,1,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CreateBundleRequest) Reset()         { *m = CreateBundleRequest{} }
func (m *CreateBundleRequest) String() string { return proto.CompactTextString(m) }
func (*CreateBundleRequest) ProtoMessage()    {}
func (*CreateBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{3}
}

func (m *CreateBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateBundleRequest.Unmarshal(m, b)
}
func (m *CreateBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateBundleRequest.Marshal(b, m, deterministic)
}
func (m *CreateBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBundleRequest.Merge(m, src)
}
func (m *CreateBundleRequest) XXX_Size() int {
	return xxx_messageInfo_CreateBundleRequest.Size(m)
}
func (m *CreateBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBundleRequest proto.InternalMessageInfo

func (m *CreateBundleRequest) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type BatchCreateBundleRequest struct {
	// The bundles to be created.
	Bundle []*types.Bundle `protobuf:"bytes,1,rep,name=bundle,proto3" json:"bundle,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchCreateBundleRequest) Reset()         { *m = BatchCreateBundleRequest{} }
func (m *BatchCreateBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchCreateBundleRequest) ProtoMessage()    {}
func (*BatchCreateBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{4}
}

func (m *BatchCreateBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchCreateBundleRequest.Unmarshal(m, b)
}
func (m *BatchCreateBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchCreateBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchCreateBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCreateBundleRequest.Merge(m, src)
}
func (m *BatchCreateBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchCreateBundleRequest.Size(m)
}
func (m *BatchCreateBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCreateBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCreateBundleRequest proto.InternalMessageInfo

func (m *BatchCreateBundleRequest) GetBundle() []*types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *BatchCreateBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchCreateBundleResponse struct {
	// Result for each bundle in the request.
	Results              []*BatchCreateBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *BatchCreateBundleResponse) Reset()         { *m = BatchCreateBundleResponse{} }
func (m *BatchCreateBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchCreateBundleResponse) ProtoMessage()    {}
func (*BatchCreateBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{5}
}

func (m *BatchCreateBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchCreateBundleResponse.Unmarshal(m, b)
}
func (m *BatchCreateBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchCreateBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchCreateBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCreateBundleResponse.Merge(m, src)
}
func (m *BatchCreateBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchCreateBundleResponse.Size(m)
}
func (m *BatchCreateBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCreateBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCreateBundleResponse proto.InternalMessageInfo

func (m *BatchCreateBundleResponse) GetResults() []*BatchCreateBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchCreateBundleResponse_Result struct {
	// The status of creating the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The bundle that was created. This will be set if the status is OK.
	Bundle               *types.Bundle `protobuf:"bytes,2,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BatchCreateBundleResponse_Result) Reset()         { *m = BatchCreateBundleResponse_Result{} }
func (m *BatchCreateBundleResponse_Result) String() string { return proto.CompactTextString(m) }
func (*BatchCreateBundleResponse_Result) ProtoMessage()    {}
func (*BatchCreateBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{5, 0}
}

func (m *BatchCreateBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchCreateBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchCreateBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchCreateBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchCreateBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCreateBundleResponse_Result.Merge(m, src)
}
func (m *BatchCreateBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchCreateBundleResponse_Result.Size(m)
}
func (m *BatchCreateBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCreateBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCreateBundleResponse_Result proto.InternalMessageInfo

func (m *BatchCreateBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchCreateBundleResponse_Result) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type UpdateBundleRequest struct {
	// Required. The bundle to update.
	Bundle *types.Bundle `protobuf:"bytes,1,opt,name=bundle,proto3" json:"bundle,omitempty"`
	// An input mask indicating which bundle fields should be updated.
	InputMask *types.BundleMask `protobuf:"bytes,2,opt,name=input_mask,json=inputMask,proto3" json:"input_mask,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,3,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UpdateBundleRequest) Reset()         { *m = UpdateBundleRequest{} }
func (m *UpdateBundleRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateBundleRequest) ProtoMessage()    {}
func (*UpdateBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{6}
}

func (m *UpdateBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateBundleRequest.Unmarshal(m, b)
}
func (m *UpdateBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateBundleRequest.Marshal(b, m, deterministic)
}
func (m *UpdateBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBundleRequest.Merge(m, src)
}
func (m *UpdateBundleRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateBundleRequest.Size(m)
}
func (m *UpdateBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBundleRequest proto.InternalMessageInfo

func (m *UpdateBundleRequest) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *UpdateBundleRequest) GetInputMask() *types.BundleMask {
	if m != nil {
		return m.InputMask
	}
	return nil
}

func (m *UpdateBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchUpdateBundleRequest struct {
	// The bundles to be updated.
	Bundle []*types.Bundle `protobuf:"bytes,1,rep,name=bundle,proto3" json:"bundle,omitempty"`
	// An input mask indicating which bundle fields should be updated.
	InputMask *types.BundleMask `protobuf:"bytes,2,opt,name=input_mask,json=inputMask,proto3" json:"input_mask,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,3,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchUpdateBundleRequest) Reset()         { *m = BatchUpdateBundleRequest{} }
func (m *BatchUpdateBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBundleRequest) ProtoMessage()    {}
func (*BatchUpdateBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{7}
}

func (m *BatchUpdateBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBundleRequest.Unmarshal(m, b)
}
func (m *BatchUpdateBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBundleRequest.Merge(m, src)
}
func (m *BatchUpdateBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBundleRequest.Size(m)
}
func (m *BatchUpdateBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBundleRequest proto.InternalMessageInfo

func (m *BatchUpdateBundleRequest) GetBundle() []*types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *BatchUpdateBundleRequest) GetInputMask() *types.BundleMask {
	if m != nil {
		return m.InputMask
	}
	return nil
}

func (m *BatchUpdateBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchUpdateBundleResponse struct {
	// Result for each bundle in the request.
	Results              []*BatchUpdateBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *BatchUpdateBundleResponse) Reset()         { *m = BatchUpdateBundleResponse{} }
func (m *BatchUpdateBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBundleResponse) ProtoMessage()    {}
func (*BatchUpdateBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{8}
}

func (m *BatchUpdateBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBundleResponse.Unmarshal(m, b)
}
func (m *BatchUpdateBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBundleResponse.Merge(m, src)
}
func (m *BatchUpdateBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBundleResponse.Size(m)
}
func (m *BatchUpdateBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBundleResponse proto.InternalMessageInfo

func (m *BatchUpdateBundleResponse) GetResults() []*BatchUpdateBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchUpdateBundleResponse_Result struct {
	// The status of updating the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The bundle that was updated. This will be set if the status is OK.
	Bundle               *types.Bundle `protobuf:"bytes,2,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BatchUpdateBundleResponse_Result) Reset()         { *m = BatchUpdateBundleResponse_Result{} }
func (m *BatchUpdateBundleResponse_Result) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBundleResponse_Result) ProtoMessage()    {}
func (*BatchUpdateBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{8, 0}
}

func (m *BatchUpdateBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchUpdateBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBundleResponse_Result.Merge(m, src)
}
func (m *BatchUpdateBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBundleResponse_Result.Size(m)
}
func (m *BatchUpdateBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBundleResponse_Result proto.InternalMessageInfo

func (m *BatchUpdateBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchUpdateBundleResponse_Result) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type SetBundleRequest struct {
	// Required. The bundle to create or update.
	Bundle *types.Bundle `protobuf:"bytes,1,opt,name=bundle,proto3" json:"bundle,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SetBundleRequest) Reset()         { *m = SetBundleRequest{} }
func (m *SetBundleRequest) String() string { return proto.CompactTextString(m) }
func (*SetBundleRequest) ProtoMessage()    {}
func (*SetBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{9}
}

func (m *SetBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetBundleRequest.Unmarshal(m, b)
}
func (m *SetBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetBundleRequest.Marshal(b, m, deterministic)
}
func (m *SetBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBundleRequest.Merge(m, src)
}
func (m *SetBundleRequest) XXX_Size() int {
	return xxx_messageInfo_SetBundleRequest.Size(m)
}
func (m *SetBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetBundleRequest proto.InternalMessageInfo

func (m *SetBundleRequest) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *SetBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchSetBundleRequest struct {
	// The bundles to be upserted.
	Bundle []*types.Bundle `protobuf:"bytes,1,rep,name=bundle,proto3" json:"bundle,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchSetBundleRequest) Reset()         { *m = BatchSetBundleRequest{} }
func (m *BatchSetBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSetBundleRequest) ProtoMessage()    {}
func (*BatchSetBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{10}
}

func (m *BatchSetBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchSetBundleRequest.Unmarshal(m, b)
}
func (m *BatchSetBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchSetBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchSetBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBundleRequest.Merge(m, src)
}
func (m *BatchSetBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchSetBundleRequest.Size(m)
}
func (m *BatchSetBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBundleRequest proto.InternalMessageInfo

func (m *BatchSetBundleRequest) GetBundle() []*types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *BatchSetBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchSetBundleResponse struct {
	// Result for each bundle in the request.
	Results              []*BatchSetBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *BatchSetBundleResponse) Reset()         { *m = BatchSetBundleResponse{} }
func (m *BatchSetBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSetBundleResponse) ProtoMessage()    {}
func (*BatchSetBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{11}
}

func (m *BatchSetBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchSetBundleResponse.Unmarshal(m, b)
}
func (m *BatchSetBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchSetBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchSetBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBundleResponse.Merge(m, src)
}
func (m *BatchSetBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchSetBundleResponse.Size(m)
}
func (m *BatchSetBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBundleResponse proto.InternalMessageInfo

func (m *BatchSetBundleResponse) GetResults() []*BatchSetBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchSetBundleResponse_Result struct {
	// The status of upserting the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The bundle that was upserted. This will be set if the status is OK.
	Bundle               *types.Bundle `protobuf:"bytes,2,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BatchSetBundleResponse_Result) Reset()         { *m = BatchSetBundleResponse_Result{} }
func (m *BatchSetBundleResponse_Result) String() string { return proto.CompactTextString(m) }
func (*BatchSetBundleResponse_Result) ProtoMessage()    {}
func (*BatchSetBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{11, 0}
}

func (m *BatchSetBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchSetBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchSetBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchSetBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchSetBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBundleResponse_Result.Merge(m, src)
}
func (m *BatchSetBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchSetBundleResponse_Result.Size(m)
}
func (m *BatchSetBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBundleResponse_Result proto.InternalMessageInfo

func (m *BatchSetBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchSetBundleResponse_Result) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type AppendBundleRequest struct {
	// Required. The bundle to append.
	Bundle *types.Bundle `protobuf:"bytes,1,opt,name=bundle,proto3" json:"bundle,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppendBundleRequest) Reset()         { *m = AppendBundleRequest{} }
func (m *AppendBundleRequest) String() string { return proto.CompactTextString(m) }
func (*AppendBundleRequest) ProtoMessage()    {}
func (*AppendBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{12}
}

func (m *AppendBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AppendBundleRequest.Unmarshal(m, b)
}
func (m *AppendBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AppendBundleRequest.Marshal(b, m, deterministic)
}
func (m *AppendBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendBundleRequest.Merge(m, src)
}
func (m *AppendBundleRequest) XXX_Size() int {
	return xxx_messageInfo_AppendBundleRequest.Size(m)
}
func (m *AppendBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendBundleRequest proto.InternalMessageInfo

func (m *AppendBundleRequest) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *AppendBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type DeleteBundleRequest struct {
	// Required. The trust domain of the bundle, e.g. example.org. It cannot
	// be the bundle for the trust domain the server belongs to.
	TrustDomain          string   `protobuf:"bytes,1,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBundleRequest) Reset()         { *m = DeleteBundleRequest{} }
func (m *DeleteBundleRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteBundleRequest) ProtoMessage()    {}
func (*DeleteBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{13}
}

func (m *DeleteBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteBundleRequest.Unmarshal(m, b)
}
func (m *DeleteBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteBundleRequest.Marshal(b, m, deterministic)
}
func (m *DeleteBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBundleRequest.Merge(m, src)
}
func (m *DeleteBundleRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteBundleRequest.Size(m)
}
func (m *DeleteBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBundleRequest proto.InternalMessageInfo

func (m *DeleteBundleRequest) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

type BatchDeleteBundleRequest struct {
	// The trust domains of the bundles to be deleted.
	TrustDomains         []string `protobuf:"bytes,1,rep,name=trust_domains,json=trustDomains,proto3" json:"trust_domains,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchDeleteBundleRequest) Reset()         { *m = BatchDeleteBundleRequest{} }
func (m *BatchDeleteBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchDeleteBundleRequest) ProtoMessage()    {}
func (*BatchDeleteBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{14}
}

func (m *BatchDeleteBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchDeleteBundleRequest.Unmarshal(m, b)
}
func (m *BatchDeleteBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchDeleteBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchDeleteBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchDeleteBundleRequest.Merge(m, src)
}
func (m *BatchDeleteBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchDeleteBundleRequest.Size(m)
}
func (m *BatchDeleteBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchDeleteBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchDeleteBundleRequest proto.InternalMessageInfo

func (m *BatchDeleteBundleRequest) GetTrustDomains() []string {
	if m != nil {
		return m.TrustDomains
	}
	return nil
}

type BatchDeleteBundleResponse struct {
	// Result for each bundle in the request.
	Results              []*BatchDeleteBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *BatchDeleteBundleResponse) Reset()         { *m = BatchDeleteBundleResponse{} }
func (m *BatchDeleteBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchDeleteBundleResponse) ProtoMessage()    {}
func (*BatchDeleteBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{15}
}

func (m *BatchDeleteBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchDeleteBundleResponse.Unmarshal(m, b)
}
func (m *BatchDeleteBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchDeleteBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchDeleteBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchDeleteBundleResponse.Merge(m, src)
}
func (m *BatchDeleteBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchDeleteBundleResponse.Size(m)
}
func (m *BatchDeleteBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchDeleteBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchDeleteBundleResponse proto.InternalMessageInfo

func (m *BatchDeleteBundleResponse) GetResults() []*BatchDeleteBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchDeleteBundleResponse_Result struct {
	// The status of deleting the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The trust domain of the bundle that was deleted.
	TrustDomain          string   `protobuf:"bytes,2,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchDeleteBundleResponse_Result) Reset()         { *m = BatchDeleteBundleResponse_Result{} }
func (m *BatchDeleteBundleResponse_Result) String() string { return proto.CompactTextString(m) }
func (*BatchDeleteBundleResponse_Result) ProtoMessage()    {}
func (*BatchDeleteBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf01a1817f9fc5c2, []int{15, 0}
}

func (m *BatchDeleteBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchDeleteBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchDeleteBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchDeleteBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchDeleteBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchDeleteBundleResponse_Result.Merge(m, src)
}
func (m *BatchDeleteBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchDeleteBundleResponse_Result.Size(m)
}
func (m *BatchDeleteBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchDeleteBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchDeleteBundleResponse_Result proto.InternalMessageInfo

func (m *BatchDeleteBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchDeleteBundleResponse_Result) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func init() {
	proto.RegisterType((*ListBundlesRequest)(nil), "spire.api.bundle.v1.ListBundlesRequest")
	proto.RegisterType((*ListBundlesResponse)(nil), "spire.api.bundle.v1.ListBundlesResponse")
	proto.RegisterType((*GetBundleRequest)(nil), "spire.api.bundle.v1.GetBundleRequest")
	proto.RegisterType((*CreateBundleRequest)(nil), "spire.api.bundle.v1.CreateBundleRequest")
	proto.RegisterType((*BatchCreateBundleRequest)(nil), "spire.api.bundle.v1.BatchCreateBundleRequest")
	proto.RegisterType((*BatchCreateBundleResponse)(nil), "spire.api.bundle.v1.BatchCreateBundleResponse")
	proto.RegisterType((*BatchCreateBundleResponse_Result)(nil), "spire.api.bundle.v1.BatchCreateBundleResponse.Result")
	proto.RegisterType((*UpdateBundleRequest)(nil), "spire.api.bundle.v1.UpdateBundleRequest")
	proto.RegisterType((*BatchUpdateBundleRequest)(nil), "spire.api.bundle.v1.BatchUpdateBundleRequest")
	proto.RegisterType((*BatchUpdateBundleResponse)(nil), "spire.api.bundle.v1.BatchUpdateBundleResponse")
	proto.RegisterType((*BatchUpdateBundleResponse_Result)(nil), "spire.api.bundle.v1.BatchUpdateBundleResponse.Result")
	proto.RegisterType((*SetBundleRequest)(nil), "spire.api.bundle.v1.SetBundleRequest")
	proto.RegisterType((*BatchSetBundleRequest)(nil), "spire.api.bundle.v1.BatchSetBundleRequest")
	proto.RegisterType((*BatchSetBundleResponse)(nil), "spire.api.bundle.v1.BatchSetBundleResponse")
	proto.RegisterType((*BatchSetBundleResponse_Result)(nil), "spire.api.bundle.v1.BatchSetBundleResponse.Result")
	proto.RegisterType((*AppendBundleRequest)(nil), "spire.api.bundle.v1.AppendBundleRequest")
	proto.RegisterType((*DeleteBundleRequest)(nil), "spire.api.bundle.v1.DeleteBundleRequest")
	proto.RegisterType((*BatchDeleteBundleRequest)(nil), "spire.api.bundle.v1.BatchDeleteBundleRequest")
	proto.RegisterType((*BatchDeleteBundleResponse)(nil), "spire.api.bundle.v1.BatchDeleteBundleResponse")
	proto.RegisterType((*BatchDeleteBundleResponse_Result)(nil), "spire.api.bundle.v1.BatchDeleteBundleResponse.Result")
}

func init() { proto.RegisterFile("bundle.proto", fileDescriptor_cf01a1817f9fc5c2) }

var fileDescriptor_cf01a1817f9fc5c2 = []byte{
	// 752 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x51, 0x6b, 0x13, 0x4f,
	0x10, 0xe7, 0x12, 0xfe, 0x69, 0x33, 0x49, 0xff, 0xd6, 0x3d, 0xac, 0x31, 0xa5, 0x50, 0x23, 0x6a,
	0xb0, 0x64, 0x8f, 0x46, 0x2a, 0x05, 0x91, 0x62, 0xac, 0xf4, 0xa5, 0xc5, 0x72, 0x51, 0x10, 0x5f,
	0xe2, 0xa5, 0xd9, 0xa6, 0x47, 0x93, 0xbb, 0x35, 0xbb, 0x57, 0x6c, 0x11, 0x41, 0x3f, 0x93, 0x2f,
	0x7e, 0x01, 0x1f, 0x7c, 0xf2, 0x23, 0xc9, 0xed, 0xde, 0x85, 0xbb, 0xcb, 0x5e, 0xef, 0x1a, 0x91,
	0xfa, 0x76, 0xec, 0xcd, 0xfc, 0xf6, 0x37, 0xf3, 0x9b, 0x9d, 0xd9, 0x85, 0x6a, 0xdf, 0x73, 0x06,
	0x23, 0x82, 0xe9, 0xc4, 0xe5, 0x2e, 0xd2, 0x19, 0xb5, 0x27, 0x04, 0x5b, 0xd4, 0xc6, 0xc1, 0xfa,
	0xd9, 0x66, 0x7d, 0x75, 0xe8, 0xba, 0xc3, 0x11, 0x31, 0x84, 0x49, 0xdf, 0x3b, 0x36, 0xc8, 0x98,
	0xf2, 0x73, 0xe9, 0x51, 0x5f, 0x13, 0x1e, 0x86, 0x43, 0x3e, 0x72, 0x83, 0x9f, 0x53, 0xc2, 0x8c,
	0x28, 0xa0, 0xe2, 0x37, 0xe3, 0x16, 0xf7, 0x98, 0xfc, 0xdd, 0x38, 0x04, 0xb4, 0x6f, 0x33, 0xde,
	0x11, 0x2e, 0xcc, 0x24, 0x1f, 0x3c, 0xc2, 0x38, 0x5a, 0x85, 0x32, 0xb5, 0x86, 0xa4, 0xc7, 0xec,
	0x0b, 0x52, 0x2b, 0xac, 0x6b, 0xcd, 0xff, 0xcc, 0x45, 0x7f, 0xa1, 0x6b, 0x5f, 0x10, 0xb4, 0x06,
	0x20, 0x7e, 0x72, 0xf7, 0x94, 0x38, 0xb5, 0xe2, 0xba, 0xd6, 0x2c, 0x9b, 0xc2, 0xfc, 0xb5, 0xbf,
	0xd0, 0x18, 0x81, 0x1e, 0x43, 0x64, 0xd4, 0x75, 0x18, 0x41, 0x2d, 0x58, 0x90, 0xbc, 0x58, 0x4d,
	0x5b, 0x2f, 0x36, 0x2b, 0x6d, 0x1d, 0xcb, 0x50, 0x05, 0x29, 0x2c, 0xcd, 0xcd, 0xd0, 0x06, 0x3d,
	0x80, 0x1b, 0x3e, 0xe5, 0x5e, 0x64, 0xa7, 0x82, 0xd8, 0x69, 0xc9, 0x5f, 0x3e, 0x9c, 0xee, 0xb6,
	0x05, 0xcb, 0x7b, 0x24, 0xd8, 0x2c, 0x64, 0x7f, 0x17, 0xaa, 0x7c, 0xe2, 0x31, 0xde, 0x1b, 0xb8,
	0x63, 0xcb, 0x76, 0x6a, 0x9a, 0x70, 0xac, 0x88, 0xb5, 0x5d, 0xb1, 0xd4, 0xe8, 0x80, 0xfe, 0x62,
	0x42, 0x2c, 0x4e, 0xe2, 0x9e, 0x1b, 0x50, 0x92, 0x04, 0x84, 0x4f, 0x0a, 0xc7, 0xc0, 0xa4, 0xf1,
	0x45, 0x83, 0x5a, 0xc7, 0xe2, 0x47, 0x27, 0x59, 0x48, 0xc5, 0x0c, 0x24, 0xb4, 0x0d, 0x15, 0xd7,
	0xe3, 0xd4, 0xe3, 0xbd, 0xb1, 0xc5, 0x4e, 0x45, 0xa0, 0x95, 0xf6, 0x6d, 0x85, 0xc7, 0x81, 0xc5,
	0x4e, 0x4d, 0x90, 0xb6, 0xfe, 0x77, 0xe3, 0x97, 0x06, 0x77, 0x14, 0x1c, 0x82, 0x9c, 0xbf, 0x82,
	0x85, 0x09, 0x61, 0xde, 0x88, 0x87, 0x39, 0xdf, 0xc2, 0x8a, 0xf2, 0xc2, 0xa9, 0x00, 0xd8, 0x14,
	0xde, 0x66, 0x88, 0x52, 0xef, 0x43, 0x49, 0x2e, 0xf9, 0xf1, 0xc9, 0x3a, 0x52, 0x66, 0xaa, 0x2b,
	0x7e, 0x99, 0x81, 0x49, 0x24, 0x19, 0x85, 0xec, 0xb4, 0x7e, 0xd3, 0x40, 0x7f, 0x43, 0x07, 0x7f,
	0xa4, 0x0d, 0x7a, 0x02, 0x60, 0x3b, 0x79, 0x13, 0x5a, 0x16, 0xa6, 0xfe, 0x67, 0x52, 0x89, 0x62,
	0x7e, 0x25, 0xbe, 0x87, 0xd5, 0x90, 0xc5, 0xbd, 0xf8, 0xef, 0x71, 0x9f, 0x56, 0x51, 0x9c, 0xfb,
	0x1c, 0x55, 0xa4, 0x02, 0xb8, 0x96, 0x2a, 0x3a, 0x87, 0xe5, 0x6e, 0xb2, 0x2f, 0x5c, 0xa9, 0x82,
	0xe6, 0x3f, 0x93, 0x9f, 0xe1, 0x96, 0xc8, 0xc5, 0xa5, 0xfb, 0xff, 0xc5, 0x9e, 0xf0, 0x53, 0x83,
	0x95, 0x24, 0x81, 0x40, 0xca, 0xfd, 0xa4, 0x94, 0xed, 0x74, 0x29, 0x67, 0xbc, 0xaf, 0x45, 0xc7,
	0x4f, 0xa0, 0x3f, 0xa7, 0x94, 0x38, 0x83, 0x6b, 0x91, 0x72, 0x1b, 0xf4, 0x5d, 0x32, 0x22, 0xc9,
	0xe3, 0x9c, 0x63, 0xc0, 0xec, 0x04, 0xdd, 0x40, 0xe5, 0x7e, 0x0f, 0x96, 0xa2, 0xee, 0x52, 0x8b,
	0xb2, 0x59, 0x8d, 0xf8, 0xb3, 0xc6, 0x8f, 0xf0, 0x4c, 0xc6, 0x11, 0xe6, 0x38, 0x93, 0x2a, 0x80,
	0x19, 0x2d, 0xdf, 0xce, 0xa7, 0x65, 0x32, 0x13, 0x85, 0x99, 0x4c, 0xb4, 0xbf, 0x2e, 0x42, 0x49,
	0x6e, 0x8e, 0xde, 0x43, 0x25, 0x72, 0x35, 0x40, 0x0f, 0x95, 0x9c, 0x67, 0xaf, 0x23, 0xf5, 0x66,
	0xb6, 0x61, 0x90, 0x97, 0x3d, 0x28, 0x4f, 0xaf, 0x03, 0xe8, 0xbe, 0xd2, 0x2d, 0x79, 0x5d, 0xa8,
	0xab, 0x6a, 0x07, 0x1d, 0x40, 0x35, 0x3a, 0x11, 0x91, 0x9a, 0x82, 0x62, 0xf2, 0xab, 0xe1, 0x26,
	0x70, 0x73, 0x66, 0xca, 0xa2, 0x56, 0xde, 0x69, 0x2c, 0x81, 0xf1, 0xd5, 0x86, 0xb7, 0x1f, 0x42,
	0xb4, 0x1d, 0xa7, 0x84, 0xa0, 0x18, 0x57, 0x97, 0x87, 0x10, 0xc3, 0x6c, 0xe5, 0x1d, 0x05, 0x99,
	0x21, 0x28, 0x47, 0xcf, 0x1e, 0x94, 0xbb, 0x19, 0x72, 0x76, 0x73, 0xc9, 0x69, 0xc3, 0xff, 0xf1,
	0xa6, 0x86, 0x1e, 0xe5, 0xea, 0x7c, 0x12, 0x72, 0xe3, 0x0a, 0x5d, 0xd2, 0x4f, 0x7b, 0xb4, 0x63,
	0xa5, 0xa4, 0x5d, 0xd1, 0xd4, 0xd4, 0xcc, 0x0f, 0xa1, 0x1a, 0x3d, 0xc0, 0x29, 0x70, 0x8a, 0x36,
	0x53, 0x5f, 0xc1, 0xf2, 0xd9, 0x80, 0xc3, 0x67, 0x03, 0x7e, 0xe9, 0x3f, 0x1b, 0xa6, 0x42, 0xc6,
	0x60, 0x5b, 0x79, 0xfb, 0x47, 0xa6, 0x90, 0xaa, 0x76, 0xd3, 0xd9, 0x79, 0xf7, 0x6c, 0x68, 0xf3,
	0x13, 0xaf, 0x8f, 0x8f, 0xdc, 0xb1, 0xc1, 0xa8, 0x7d, 0x7c, 0x4c, 0x0c, 0xf9, 0x32, 0x11, 0xec,
	0x8c, 0xc8, 0x2b, 0xc5, 0xa2, 0x76, 0xf0, 0x84, 0x31, 0xce, 0x36, 0x9f, 0xca, 0xaf, 0x7e, 0x49,
	0x98, 0x3d, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xcd, 0xbf, 0x09, 0x2e, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BundleClient is the client API for Bundle service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BundleClient interface {
	// Lists bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	ListBundles(ctx context.Context, in *ListBundlesRequest, opts ...grpc.CallOption) (*ListBundlesResponse, error)
	// Gets a bundle. If the bundle does not exist, NOT_FOUND is returned.
	//
	// The caller must be local or present an admin X509-SVID, unless the
	// bundle for the trust domain of the server is requested, in which case,
	// the RPC is unauthenticated.
	GetBundle(ctx context.Context, in *GetBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Creates a bundle. If the bundle already exists, ALREADY_EXISTS is
	// returned. If the bundle is for the trust domain of the SPIRE server,
	// INVALID_ARGUMENT is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	CreateBundle(ctx context.Context, in *CreateBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Batch creates one or more bundles. See CreateBundle for details on
	// the status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchCreateBundle(ctx context.Context, in *BatchCreateBundleRequest, opts ...grpc.CallOption) (*BatchCreateBundleResponse, error)
	// Updates a bundle. If the bundle does not exist, NOT_FOUND is returned.
	// If the bundle is for the trust domain of the SPIRE server,
	// INVALID_ARGUMENT is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	UpdateBundle(ctx context.Context, in *UpdateBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Batch updates one or more bundles. See UpdateBundle for details on
	// the status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchUpdateBundle(ctx context.Context, in *BatchUpdateBundleRequest, opts ...grpc.CallOption) (*BatchUpdateBundleResponse, error)
	// Sets a bundle, creating a new bundle if one doesn't already exist for
	// the trust domain, or otherwise updating the existing bundle. If the
	// bundle is for the trust domain of the SPIRE server, INVALID_ARGUMENT is
	// returned.
	//
	// The caller must be local or present an admin X509-SVID.
	SetBundle(ctx context.Context, in *SetBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Batch upserts one or more bundles. See SetBundle for details on the
	// status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchSetBundle(ctx context.Context, in *BatchSetBundleRequest, opts ...grpc.CallOption) (*BatchSetBundleResponse, error)
	// Append to a bundle. Items specified in the bundle in the request are
	// appended to the existing bundle. If the bundle does not exist, NOT_FOUND
	// is returned. This is the only RPC that can be used to update the
	// bundle for the trust domain of the SPIRE server.
	//
	// The caller must be local or present an admin or downstream X509-SVID.
	AppendBundle(ctx context.Context, in *AppendBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Deletes a bundle. If the bundle does not exist, NOT_FOUND is returned.
	// If the bundle is for the trust domain of the SPIRE server,
	// INVALID_ARGUMENT is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	DeleteBundle(ctx context.Context, in *DeleteBundleRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Batch deletes one or more bundles. See DeleteBundle for details on
	// the status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchDeleteBundle(ctx context.Context, in *BatchDeleteBundleRequest, opts ...grpc.CallOption) (*BatchDeleteBundleResponse, error)
}

type bundleClient struct {
	cc *grpc.ClientConn
}

func NewBundleClient(cc *grpc.ClientConn) BundleClient {
	return &bundleClient{cc}
}

func (c *bundleClient) ListBundles(ctx context.Context, in *ListBundlesRequest, opts ...grpc.CallOption) (*ListBundlesResponse, error) {
	out := new(ListBundlesResponse)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/ListBundles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) GetBundle(ctx context.Context, in *GetBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/GetBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) CreateBundle(ctx context.Context, in *CreateBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/CreateBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchCreateBundle(ctx context.Context, in *BatchCreateBundleRequest, opts ...grpc.CallOption) (*BatchCreateBundleResponse, error) {
	out := new(BatchCreateBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/BatchCreateBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) UpdateBundle(ctx context.Context, in *UpdateBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/UpdateBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchUpdateBundle(ctx context.Context, in *BatchUpdateBundleRequest, opts ...grpc.CallOption) (*BatchUpdateBundleResponse, error) {
	out := new(BatchUpdateBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/BatchUpdateBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) SetBundle(ctx context.Context, in *SetBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/SetBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchSetBundle(ctx context.Context, in *BatchSetBundleRequest, opts ...grpc.CallOption) (*BatchSetBundleResponse, error) {
	out := new(BatchSetBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/BatchSetBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) AppendBundle(ctx context.Context, in *AppendBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/AppendBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) DeleteBundle(ctx context.Context, in *DeleteBundleRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/DeleteBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchDeleteBundle(ctx context.Context, in *BatchDeleteBundleRequest, opts ...grpc.CallOption) (*BatchDeleteBundleResponse, error) {
	out := new(BatchDeleteBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.bundle.v1.Bundle/BatchDeleteBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BundleServer is the server API for Bundle service.
type BundleServer interface {
	// Lists bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	ListBundles(context.Context, *ListBundlesRequest) (*ListBundlesResponse, error)
	// Gets a bundle. If the bundle does not exist, NOT_FOUND is returned.
	//
	// The caller must be local or present an admin X509-SVID, unless the
	// bundle for the trust domain of the server is requested, in which case,
	// the RPC is unauthenticated.
	GetBundle(context.Context, *GetBundleRequest) (*types.Bundle, error)
	// Creates a bundle. If the bundle already exists, ALREADY_EXISTS is
	// returned. If the bundle is for the trust domain of the SPIRE server,
	// INVALID_ARGUMENT is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	CreateBundle(context.Context, *CreateBundleRequest) (*types.Bundle, error)
	// Batch creates one or more bundles. See CreateBundle for details on
	// the status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchCreateBundle(context.Context, *BatchCreateBundleRequest) (*BatchCreateBundleResponse, error)
	// Updates a bundle. If the bundle does not exist, NOT_FOUND is returned.
	// If the bundle is for the trust domain of the SPIRE server,
	// INVALID_ARGUMENT is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	UpdateBundle(context.Context, *UpdateBundleRequest) (*types.Bundle, error)
	// Batch updates one or more bundles. See UpdateBundle for details on
	// the status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchUpdateBundle(context.Context, *BatchUpdateBundleRequest) (*BatchUpdateBundleResponse, error)
	// Sets a bundle, creating a new bundle if one doesn't already exist for
	// the trust domain, or otherwise updating the existing bundle. If the
	// bundle is for the trust domain of the SPIRE server, INVALID_ARGUMENT is
	// returned.
	//
	// The caller must be local or present an admin X509-SVID.
	SetBundle(context.Context, *SetBundleRequest) (*types.Bundle, error)
	// Batch upserts one or more bundles. See SetBundle for details on the
	// status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchSetBundle(context.Context, *BatchSetBundleRequest) (*BatchSetBundleResponse, error)
	// Append to a bundle. Items specified in the bundle in the request are
	// appended to the existing bundle. If the bundle does not exist, NOT_FOUND
	// is returned. This is the only RPC that can be used to update the
	// bundle for the trust domain of the SPIRE server.
	//
	// The caller must be local or present an admin or downstream X509-SVID.
	AppendBundle(context.Context, *AppendBundleRequest) (*types.Bundle, error)
	// Deletes a bundle. If the bundle does not exist, NOT_FOUND is returned.
	// If the bundle is for the trust domain of the SPIRE server,
	// INVALID_ARGUMENT is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	DeleteBundle(context.Context, *DeleteBundleRequest) (*empty.Empty, error)
	// Batch deletes one or more bundles. See DeleteBundle for details on
	// the status codes that will be returned in the results.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchDeleteBundle(context.Context, *BatchDeleteBundleRequest) (*BatchDeleteBundleResponse, error)
}

// UnimplementedBundleServer can be embedded to have forward compatible implementations.
type UnimplementedBundleServer struct {
}

func (*UnimplementedBundleServer) ListBundles(ctx context.Context, req *ListBundlesRequest) (*ListBundlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBundles not implemented")
}
func (*UnimplementedBundleServer) GetBundle(ctx context.Context, req *GetBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBundle not implemented")
}
func (*UnimplementedBundleServer) CreateBundle(ctx context.Context, req *CreateBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBundle not implemented")
}
func (*UnimplementedBundleServer) BatchCreateBundle(ctx context.Context, req *BatchCreateBundleRequest) (*BatchCreateBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateBundle not implemented")
}
func (*UnimplementedBundleServer) UpdateBundle(ctx context.Context, req *UpdateBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBundle not implemented")
}
func (*UnimplementedBundleServer) BatchUpdateBundle(ctx context.Context, req *BatchUpdateBundleRequest) (*BatchUpdateBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateBundle not implemented")
}
func (*UnimplementedBundleServer) SetBundle(ctx context.Context, req *SetBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBundle not implemented")
}
func (*UnimplementedBundleServer) BatchSetBundle(ctx context.Context, req *BatchSetBundleRequest) (*BatchSetBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSetBundle not implemented")
}
func (*UnimplementedBundleServer) AppendBundle(ctx context.Context, req *AppendBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendBundle not implemented")
}
func (*UnimplementedBundleServer) DeleteBundle(ctx context.Context, req *DeleteBundleRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBundle not implemented")
}
func (*UnimplementedBundleServer) BatchDeleteBundle(ctx context.Context, req *BatchDeleteBundleRequest) (*BatchDeleteBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteBundle not implemented")
}

func RegisterBundleServer(s *grpc.Server, srv BundleServer) {
	s.RegisterService(&_Bundle_serviceDesc, srv)
}

func _Bundle_ListBundles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBundlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).ListBundles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/ListBundles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).ListBundles(ctx, req.(*ListBundlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_GetBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).GetBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/GetBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).GetBundle(ctx, req.(*GetBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_CreateBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).CreateBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/CreateBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).CreateBundle(ctx, req.(*CreateBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchCreateBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchCreateBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/BatchCreateBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchCreateBundle(ctx, req.(*BatchCreateBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_UpdateBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).UpdateBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/UpdateBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).UpdateBundle(ctx, req.(*UpdateBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchUpdateBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchUpdateBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/BatchUpdateBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchUpdateBundle(ctx, req.(*BatchUpdateBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_SetBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).SetBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/SetBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).SetBundle(ctx, req.(*SetBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchSetBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSetBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchSetBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/BatchSetBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchSetBundle(ctx, req.(*BatchSetBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_AppendBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).AppendBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/AppendBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).AppendBundle(ctx, req.(*AppendBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_DeleteBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).DeleteBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/DeleteBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).DeleteBundle(ctx, req.(*DeleteBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchDeleteBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchDeleteBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.bundle.v1.Bundle/BatchDeleteBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchDeleteBundle(ctx, req.(*BatchDeleteBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bundle_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spire.api.bundle.v1.Bundle",
	HandlerType: (*BundleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBundles",
			Handler:    _Bundle_ListBundles_Handler,
		},
		{
			MethodName: "GetBundle",
			Handler:    _Bundle_GetBundle_Handler,
		},
		{
			MethodName: "CreateBundle",
			Handler:    _Bundle_CreateBundle_Handler,
		},
		{
			MethodName: "BatchCreateBundle",
			Handler:    _Bundle_BatchCreateBundle_Handler,
		},
		{
			MethodName: "UpdateBundle",
			Handler:    _Bundle_UpdateBundle_Handler,
		},
		{
			MethodName: "BatchUpdateBundle",
			Handler:    _Bundle_BatchUpdateBundle_Handler,
		},
		{
			MethodName: "SetBundle",
			Handler:    _Bundle_SetBundle_Handler,
		},
		{
			MethodName: "BatchSetBundle",
			Handler:    _Bundle_BatchSetBundle_Handler,
		},
		{
			MethodName: "AppendBundle",
			Handler:    _Bundle_AppendBundle_Handler,
		},
		{
			MethodName: "DeleteBundle",
			Handler:    _Bundle_DeleteBundle_Handler,
		},
		{
			MethodName: "BatchDeleteBundle",
			Handler:    _Bundle_BatchDeleteBundle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bundle.proto",
}
